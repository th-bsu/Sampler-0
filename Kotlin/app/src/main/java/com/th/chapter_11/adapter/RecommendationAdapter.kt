package com.th.chapter_11.adapter

import android.graphics.Color
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.th.chapter_11.R
import com.th.chapter_11.ShelterActivity
import com.th.chapter_11.db.RecommendationEntity

class RecommendationAdapter(
    private val layoutInflater: LayoutInflater,
    interface_: Int,
    rowInput: Int
)
    :RecyclerView.Adapter<RecommendationAdapter.PostViewHolder>()
{

    // TH: manages mutable ordered collection of elements.
    private val recommendations = mutableListOf<RecommendationEntity>()

    // TH: indicates if matched, based on search.
    private lateinit var matched:  ArrayList<Int>

    // TH: indicates if matched, based on anchor (i.e. recommendations).
    private lateinit var anchored: ArrayList<Int>

    // TH: indicates if matched, based on delete (i.e. recommendations).
    private lateinit var matchedDelete: ArrayList<Int>

    // TH: indicates if matched, based on delete-selected.
    private lateinit var matchedDeleteSelected: ArrayList<Int>

    // TH: indicates if matched, based on anchor-selected.
    private lateinit var matchedAnchorSelected: ArrayList<Int>

    // TH: helps clear background highlights.
    private var clearRecommendation: Int = 0
    private var clearRecommendationForDelete: Int = 0
    private var clearRecommendationForAnchor: Int = 0

    // TH: represents color of interest.
    companion object {
        const val ORANGE = "#FFA500"
        const val BLUE   = "#0000FF" // #B0E0E6.
        const val GREEN  = "#00ff00"
        const val BACKEND  = 0
        const val FRONTEND = 1
    }

    private lateinit var recListener: OnItemClickListener

    interface OnItemClickListener {
        fun onItemClick(
            row: Int,
            position: Int
        )
    }

    private var userInterface: Int = interface_

    // TH: holds on to row.
    private var row: Int = rowInput

    // TH: receives explicit implementation from caller (i.e. pipes Adapter position to caller).
    // TH: https://www.youtube.com/watch?v=dB9JOsVx-yY
    fun setOnItemClickListener(listener: OnItemClickListener){
        recListener = listener
    }

    // TH: holds on reference to given view(s) and binds data to given view(s).
    inner class PostViewHolder (
        containView: View,              /* gets generated by LayoutInflater. */
        listener: OnItemClickListener   /* gets listened on by View.         */
    )
        :RecyclerView.ViewHolder(containView)
    {

        private var containViewLocal: View

        init {
            // TH: registers callback that gets invoked when view clicked.
            // TH: basically, pipes Adapter position to caller.
            containView.setOnClickListener {
                listener.onItemClick(
                    row,
                    absoluteAdapterPosition
                )
            }
            containViewLocal = containView
        }

        /*
        // TH: original.
        // TH: specifies frontEnd.
        private val textViewProId: TextView   = containView.findViewById(R.id.view_recommendation_row_product_id)
        private val textViewRow: TextView     = containView.findViewById(R.id.view_recommendation_row_position_row)
        private val textViewOffset: TextView  = containView.findViewById(R.id.view_recommendation_row_position_offset)
        */

        // TH: specifies View, based on interface.
        private lateinit var imageView: ImageView
        private lateinit var textViewProId: TextView
        private lateinit var textViewRow: TextView
        private lateinit var textViewOffset: TextView
        private lateinit var textViewDummy: TextView

        fun bind(recEntity: RecommendationEntity){

            if(userInterface!=BACKEND){

                imageView = containViewLocal.findViewById(R.id.view_recommendation_row_poster)

                // TH: experimental.
                // TH: loads imageView, based on URL (i.e. ignores dummy).
                if(
                    recEntity.productId.toString()==ShelterActivity.LAYOUT_DUMMY_ID_PRODUCT
                ){
                    Glide.with(containViewLocal.context)
                        .load(R.mipmap.ic_launcher)
                        .placeholder(R.mipmap.ic_launcher)
                        .fitCenter()
                        .into(imageView)
                }
                else{
                    Glide.with(containViewLocal.context)
                        .load(recEntity.url)
                        .diskCacheStrategy(DiskCacheStrategy.AUTOMATIC)
                        .placeholder(R.mipmap.ic_launcher)
                        .fitCenter()
                        .into(imageView)
                }

                textViewProId  = containViewLocal.findViewById(R.id.view_recommendation_row_product_id)
                textViewRow    = containViewLocal.findViewById(R.id.view_recommendation_row_position_row)
                textViewOffset = containViewLocal.findViewById(R.id.view_recommendation_row_position_offset)

                textViewProId.text    = recEntity.productId.toString()
                textViewRow.text      = recEntity.row.toString()
                textViewOffset.text   = recEntity.offset.toString()

            }

            else{
                textViewDummy         = containViewLocal.findViewById(R.id.view_recommendation_row_dummy)

                // TH: experimental.
                if(recEntity.productId==ShelterActivity.LAYOUT_DUMMY_ID_PRODUCT.toLong()){
                    textViewDummy.text    = " "
                }
                else{
                    textViewDummy.text    = "*"
                }

            }

        }//bind.

    }//PostViewHolder.

    // TH: gets invoked when RecyclerView needs new ViewHolder of the given type to represent item.
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PostViewHolder {

        if(userInterface!=BACKEND)
            return PostViewHolder(
                layoutInflater.inflate(R.layout.view_recommendation_row,parent,false),
                recListener
            )

        return PostViewHolder(
            layoutInflater.inflate(R.layout.view_recommendation_row_be,parent,false),
            recListener
        )

    }//onCreateViewHolder.

    // TH: gets invoked by RecyclerView to display the data at the specified position.
    override fun onBindViewHolder(holder: PostViewHolder, position: Int) {

        holder.bind(recommendations[position])

        // TH: if clear signal disabled (i.e. highlight enabled: search, anchor).
        if(clearRecommendation==0){

            // TH: highlights child view(s) within RecyclerView, based on match and row.
            if(anchored[position]==1){
                // TH: gets highlighted when selected, for anchor.
                if(matchedAnchorSelected[position]==1){
                    holder.itemView.setBackgroundColor(Color.GREEN)
                }
                else{
                    holder.itemView.setBackgroundColor(Color.YELLOW)
                }
            }
            else if(anchored[position]==0 && matched[position]==1) {
                if(recommendations[0].row%2==0){
                    holder.itemView.setBackgroundColor(Color.parseColor(ORANGE))
                }
                else{
                    holder.itemView.setBackgroundColor(Color.parseColor(BLUE))
                }
            }
            else{
                holder.itemView.setBackgroundColor(Color.WHITE)
            }

        }//if highlight enabled.
        else{
            holder.itemView.setBackgroundColor(Color.WHITE)
        }//else highlight disabled.

        // TH: if clear signal disabled (i.e. highlight enabled: delete).
        if(clearRecommendationForDelete==0){

            if(matchedDelete[position]==1){

                // TH: removes match for delete.
                if(matched[position]==1)  matched[position]=0

                // TH: removes anchor for delete.
                if(anchored[position]==1) anchored[position]=0

                // TH: highlights child view(s) within RecyclerView.
                if(matchedDeleteSelected[position]==0){
                    // TH: gets highlighted when found, for delete.
                    holder.itemView.setBackgroundColor(Color.YELLOW)
                }
                else{
                    // TH: gets highlighted when selected, for delete.
                    holder.itemView.setBackgroundColor(Color.RED)
                }

            }

        }//if highlight enabled.
        else{

            if(matchedDelete[position]==1){
                matchedDelete[position]=0
                matchedDeleteSelected[position]=0
                holder.itemView.setBackgroundColor(Color.WHITE)
            }

        }//else highlight disabled.

    }//onBindViewHolder.

    override fun getItemCount(): Int {
        return recommendations.size
    }

    // TH: notifies any registered observers that the data set has changed.
    // TH: forces any observers to assume that all existing items and structure may no longer be valid.
    fun updateRecommendations(recommendations: List<RecommendationEntity>) {

        // TH: helps with highlights.
        matched = arrayListOf(recommendations.size)
        for (index in recommendations.indices) matched.add(index,0)

        // TH: helps with anchors for insertion.
        anchored = arrayListOf(recommendations.size)
        for (index in recommendations.indices) anchored.add(index,0)

        // TH: helps with anchor (i.e. green, ready for insert).
        matchedAnchorSelected = arrayListOf(recommendations.size)
        for (index in recommendations.indices) matchedAnchorSelected.add(index,0)

        // TH: helps with delete (i.e. yellow, recommended for delete).
        matchedDelete = arrayListOf(recommendations.size)
        for (index in recommendations.indices) matchedDelete.add(index,0)

        // TH: helps with delete (i.e. red, ready for deletion).
        matchedDeleteSelected = arrayListOf(recommendations.size)
        for (index in recommendations.indices) matchedDeleteSelected.add(index,0)

        // TH: sorts by multiple fields.
        // TH: https://stackoverflow.com/questions/37259159/sort-collection-by-multiple-fields-in-kotlin
        this.recommendations.clear()
        this.recommendations.addAll(recommendations.sortedWith(compareBy({it.row},{it.offset})))

        // TH: enables clear signal (i.e. disables highlights).
        clearRecommendation = 1
        clearRecommendationForDelete = 1
        clearRecommendationForAnchor = 1

        /*
        // TH: original, crashes frequently.
        // TH: helps invoke data binding by ViewHolder.
        this.notifyItemRangeInserted(0,recommendations.size)
        */

        // TH: experimental, works well with OnClickListener.
        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

    }//updateRecommendations.

    // TH: clears out ALL highlights (i.e. search, anchor, delete).
    fun clearRecommendations() {

        matched = arrayListOf(recommendations.size)
        for (index in 0 until recommendations.size) matched.add(index,0)

        anchored = arrayListOf(recommendations.size)
        for (index in 0 until recommendations.size) anchored.add(index,0)

        // TH: helps with anchor (i.e. green, ready for insert).
        matchedAnchorSelected = arrayListOf(recommendations.size)
        for (index in recommendations.indices) matchedAnchorSelected.add(index,0)

        matchedDelete = arrayListOf(recommendations.size)
        for (index in 0 until recommendations.size) matchedDelete.add(index,0)

        matchedDeleteSelected = arrayListOf(recommendations.size)
        for (index in 0 until recommendations.size) matchedDeleteSelected.add(index,0)

        // TH: enables clear signal (i.e. disables highlights).
        clearRecommendation = 1
        clearRecommendationForDelete = 1
        clearRecommendationForAnchor = 1

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

    }//clearRecommendations.

    fun searchRecommendations(productId: String) {

        // TH: marks child view for highlight.
        for (index in 0 until this.recommendations.size) {
            if (recommendations[index].productId.toString() == productId) matched[index] = 1
        }//for index.

        // TH: disables clear signal (i.e. enables highlights).
        clearRecommendation = 0

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

    }//searchRecommendations.

    // TH: toggles for highlight.
    fun toggleRecommendations(position: Int): Int {

        // TH: toggles selection.
        if(matched[position] == 1) matched[position] = 0
        else                       matched[position] = 1

        // TH: disables clear signal (i.e. enables highlights).
        clearRecommendation = 0

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

        if(matched[position] == 0) return 0
        return 1

    }//toggleRecommendations.

    // TH: toggles for delete.
    fun toggleRecommendationsForDelete(position: Int): Int {

        // TH: toggles selection, for delete.
        if(matchedDeleteSelected[position] == 1) matchedDeleteSelected[position] = 0
        else                                     matchedDeleteSelected[position] = 1

        // TH: disables clear signal (i.e. enables highlights, for delete).
        clearRecommendationForDelete = 0

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

        if(matchedDeleteSelected[position] == 0) return 0
        return 1

    }//toggleRecommendationsForDelete.

    // TH: toggles for anchor.
    fun toggleRecommendationsForAnchor(position: Int): Int {

        // TH: toggles selection, for anchor.
        if(matchedAnchorSelected[position] == 1) matchedAnchorSelected[position] = 0
        else                                     matchedAnchorSelected[position] = 1

        // TH: disables clear signal (i.e. enables highlights, for anchor).
        clearRecommendationForAnchor = 0

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

        if(matchedAnchorSelected[position] == 0) return 0
        return 1

    }//toggleRecommendationsForAnchor.

    fun clearRecommendationsForDelete(position: Int) {

        // TH: removes selection, for delete.
        matchedDeleteSelected[position] = 0

        // TH: disables clear signal (i.e. enables highlights, for delete).
        clearRecommendationForDelete = 0

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

    }//clearRecommendationsForDelete.

    fun clearRecommendationsForAnchor(position: Int) {

        // TH: removes selection, for anchor.
        matchedAnchorSelected[position] = 0

        // TH: disables clear signal (i.e. enables highlights, for anchor).
        clearRecommendationForAnchor = 0

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

    }//clearRecommendationsForAnchor.

    // TH: help select anchor point for insertion.
    fun selectRecommendationsForAnchor(productId: String): ArrayList<Int> {

        // TH: holds on to anchor index, within list.
        val anchorIndex: ArrayList<Int> = arrayListOf()

        // TH: marks child view as anchor.
        // TH: keeps only one anchor at any time.
        for (index in 0 until recommendations.size) {

            // TH: resets for now.
            if(anchored[index]==1) anchored[index]=0

            // TH: removes selection for now, selectable by UI later.
            matchedAnchorSelected[index] = 0

            if (recommendations[index].productId.toString() == productId) {
                anchored[index] = 1
                anchorIndex.add(index)
            }

        }//for index.

        // TH: disables clear signal (i.e. enables highlights).
        clearRecommendation = 0

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

        return anchorIndex

    }//selectRecommendationsForAnchor.

    fun getRecommendations() = recommendations
    fun getRecommendations(position: Int) = recommendations[position]

    // TH: returns list of positions for given productId, in given row.
    fun searchRecommendationsForDelete(productId: String): ArrayList<Int> {

        // TH: holds on to positions, within list.
        val deleteIndex: ArrayList<Int> = arrayListOf()

        // TH: marks child view for delete.
        for (index in 0 until recommendations.size) {
            if (recommendations[index].productId.toString() == productId) {
                matchedDelete[index] = 1
                deleteIndex.add(index)
            }
        }//for index.

        // TH: disables clear signal (i.e. enables highlights).
        clearRecommendationForDelete = 0

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

        return deleteIndex

    }//searchRecommendationsForDelete(productId).

    fun clearMatchedDeleteSelected(position: Int) {

        // TH: avoids out-of-bound.
        if(position>=recommendations.size) return

        // TH: saves previous state.
        val previousState = matchedDeleteSelected[position]

        matchedDeleteSelected = arrayListOf(recommendations.size)
        for (index in 0 until recommendations.size) matchedDeleteSelected.add(index,0)

        // TH: disables clear signal (i.e. enables highlights).
        clearRecommendationForDelete = 0

        // TH: restores previous state (i.e. helps toggle).
        matchedDeleteSelected[position] = previousState

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

    }//clearMatchedDeleteSelected.

    fun clearMatchedAnchorSelected(position: Int) {

        // TH: avoids out-of-bound.
        if(position>=recommendations.size) return

        // TH: saves previous state.
        val previousState = matchedAnchorSelected[position]

        matchedAnchorSelected = arrayListOf(recommendations.size)
        for (index in 0 until recommendations.size) matchedAnchorSelected.add(index,0)

        // TH: disables clear signal (i.e. enables highlights).
        clearRecommendationForAnchor = 0

        // TH: restores previous state (i.e. helps toggle).
        matchedAnchorSelected[position] = previousState

        // TH: helps invoke data binding by ViewHolder.
        this.notifyDataSetChanged()

    }//clearMatchedAnchorSelected.

    fun checkMatchedDelete(index: Int) = (matchedDelete[index] == 1)

    fun checkMatchedAnchor(index: Int): Boolean{
        // TH: avoids out-of-bound.
        if(index>=recommendations.size) return false
        return (anchored[index] == 1)
    }//checkMatchedAnchor.

}